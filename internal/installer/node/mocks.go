// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package node

import (
	mock "github.com/stretchr/testify/mock"
	"time"
)

// NewMockNodeClient creates a new instance of MockNodeClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockNodeClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockNodeClient {
	mock := &MockNodeClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockNodeClient is an autogenerated mock type for the NodeClient type
type MockNodeClient struct {
	mock.Mock
}

type MockNodeClient_Expecter struct {
	mock *mock.Mock
}

func (_m *MockNodeClient) EXPECT() *MockNodeClient_Expecter {
	return &MockNodeClient_Expecter{mock: &_m.Mock}
}

// CopyFile provides a mock function for the type MockNodeClient
func (_mock *MockNodeClient) CopyFile(n *Node, src string, dst string) error {
	ret := _mock.Called(n, src, dst)

	if len(ret) == 0 {
		panic("no return value specified for CopyFile")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(*Node, string, string) error); ok {
		r0 = returnFunc(n, src, dst)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockNodeClient_CopyFile_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CopyFile'
type MockNodeClient_CopyFile_Call struct {
	*mock.Call
}

// CopyFile is a helper method to define mock.On call
//   - n
//   - src
//   - dst
func (_e *MockNodeClient_Expecter) CopyFile(n interface{}, src interface{}, dst interface{}) *MockNodeClient_CopyFile_Call {
	return &MockNodeClient_CopyFile_Call{Call: _e.mock.On("CopyFile", n, src, dst)}
}

func (_c *MockNodeClient_CopyFile_Call) Run(run func(n *Node, src string, dst string)) *MockNodeClient_CopyFile_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*Node), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockNodeClient_CopyFile_Call) Return(err error) *MockNodeClient_CopyFile_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockNodeClient_CopyFile_Call) RunAndReturn(run func(n *Node, src string, dst string) error) *MockNodeClient_CopyFile_Call {
	_c.Call.Return(run)
	return _c
}

// HasFile provides a mock function for the type MockNodeClient
func (_mock *MockNodeClient) HasFile(n *Node, filePath string) bool {
	ret := _mock.Called(n, filePath)

	if len(ret) == 0 {
		panic("no return value specified for HasFile")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func(*Node, string) bool); ok {
		r0 = returnFunc(n, filePath)
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// MockNodeClient_HasFile_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HasFile'
type MockNodeClient_HasFile_Call struct {
	*mock.Call
}

// HasFile is a helper method to define mock.On call
//   - n
//   - filePath
func (_e *MockNodeClient_Expecter) HasFile(n interface{}, filePath interface{}) *MockNodeClient_HasFile_Call {
	return &MockNodeClient_HasFile_Call{Call: _e.mock.On("HasFile", n, filePath)}
}

func (_c *MockNodeClient_HasFile_Call) Run(run func(n *Node, filePath string)) *MockNodeClient_HasFile_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*Node), args[1].(string))
	})
	return _c
}

func (_c *MockNodeClient_HasFile_Call) Return(b bool) *MockNodeClient_HasFile_Call {
	_c.Call.Return(b)
	return _c
}

func (_c *MockNodeClient_HasFile_Call) RunAndReturn(run func(n *Node, filePath string) bool) *MockNodeClient_HasFile_Call {
	_c.Call.Return(run)
	return _c
}

// RunCommand provides a mock function for the type MockNodeClient
func (_mock *MockNodeClient) RunCommand(n *Node, username string, command string) error {
	ret := _mock.Called(n, username, command)

	if len(ret) == 0 {
		panic("no return value specified for RunCommand")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(*Node, string, string) error); ok {
		r0 = returnFunc(n, username, command)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockNodeClient_RunCommand_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RunCommand'
type MockNodeClient_RunCommand_Call struct {
	*mock.Call
}

// RunCommand is a helper method to define mock.On call
//   - n
//   - username
//   - command
func (_e *MockNodeClient_Expecter) RunCommand(n interface{}, username interface{}, command interface{}) *MockNodeClient_RunCommand_Call {
	return &MockNodeClient_RunCommand_Call{Call: _e.mock.On("RunCommand", n, username, command)}
}

func (_c *MockNodeClient_RunCommand_Call) Run(run func(n *Node, username string, command string)) *MockNodeClient_RunCommand_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*Node), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockNodeClient_RunCommand_Call) Return(err error) *MockNodeClient_RunCommand_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockNodeClient_RunCommand_Call) RunAndReturn(run func(n *Node, username string, command string) error) *MockNodeClient_RunCommand_Call {
	_c.Call.Return(run)
	return _c
}

// WaitReady provides a mock function for the type MockNodeClient
func (_mock *MockNodeClient) WaitReady(n *Node, timeout time.Duration) error {
	ret := _mock.Called(n, timeout)

	if len(ret) == 0 {
		panic("no return value specified for WaitReady")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(*Node, time.Duration) error); ok {
		r0 = returnFunc(n, timeout)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockNodeClient_WaitReady_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WaitReady'
type MockNodeClient_WaitReady_Call struct {
	*mock.Call
}

// WaitReady is a helper method to define mock.On call
//   - n
//   - timeout
func (_e *MockNodeClient_Expecter) WaitReady(n interface{}, timeout interface{}) *MockNodeClient_WaitReady_Call {
	return &MockNodeClient_WaitReady_Call{Call: _e.mock.On("WaitReady", n, timeout)}
}

func (_c *MockNodeClient_WaitReady_Call) Run(run func(n *Node, timeout time.Duration)) *MockNodeClient_WaitReady_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*Node), args[1].(time.Duration))
	})
	return _c
}

func (_c *MockNodeClient_WaitReady_Call) Return(err error) *MockNodeClient_WaitReady_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockNodeClient_WaitReady_Call) RunAndReturn(run func(n *Node, timeout time.Duration) error) *MockNodeClient_WaitReady_Call {
	_c.Call.Return(run)
	return _c
}
