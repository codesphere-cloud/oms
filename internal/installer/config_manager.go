// Copyright (c) Codesphere Inc.
// SPDX-License-Identifier: Apache-2.0

package installer

import (
	"fmt"
	"io"
	"net"
	"strings"

	"github.com/codesphere-cloud/oms/internal/installer/files"
	"github.com/codesphere-cloud/oms/internal/util"
)

type InstallConfigManager interface {
	// Profile management
	ApplyProfile(profile string) error
	// Configuration management
	LoadConfigFromFile(configPath string) error
	GetConfig() *files.RootConfig
	CollectInteractively() error
	Validate() error
	// Output
	GenerateSecrets() error
	WriteInstallConfig(configPath string, withComments bool) error
	WriteVault(vaultPath string, withComments bool) error
}

type InstallConfig struct {
	fileIO util.FileIO
	Config *files.RootConfig
}

func NewInstallConfigManager() InstallConfigManager {
	return &InstallConfig{
		fileIO: &util.FilesystemWriter{},
		Config: nil,
	}
}

func (g *InstallConfig) LoadConfigFromFile(configPath string) error {
	file, err := g.fileIO.Open(configPath)
	if err != nil {
		return err
	}
	defer util.CloseFileIgnoreError(file)

	data, err := io.ReadAll(file)
	if err != nil {
		return fmt.Errorf("failed to read %s: %w", configPath, err)
	}

	config := &files.RootConfig{}
	if err := config.Unmarshal(data); err != nil {
		return fmt.Errorf("failed to unmarshal %s: %w", configPath, err)
	}

	g.Config = config
	return nil
}

func (g *InstallConfig) GetConfig() *files.RootConfig {
	return g.Config
}

func (g *InstallConfig) Validate() error {
	if g.Config == nil {
		return fmt.Errorf("config not set, cannot validate")
	}

	errors := g.ValidateConfig()
	if len(errors) > 0 {
		var errMsg strings.Builder
		errMsg.WriteString("configuration validation failed:\n")
		for _, err := range errors {
			errMsg.WriteString(fmt.Sprintf("  - %s\n", err))
		}
		return fmt.Errorf("%s", errMsg.String())
	}

	return nil
}

func (g *InstallConfig) GenerateSecrets() error {
	if g.Config == nil {
		return fmt.Errorf("config not set, cannot generate secrets")
	}
	return g.generateSecrets(g.Config)
}

func (g *InstallConfig) WriteInstallConfig(configPath string, withComments bool) error {
	if g.Config == nil {
		return fmt.Errorf("no configuration provided - config is nil")
	}

	configYAML, err := g.Config.Marshal()
	if err != nil {
		return fmt.Errorf("failed to marshal config.yaml: %w", err)
	}

	if withComments {
		configYAML = AddConfigComments(configYAML)
	}

	if err := g.fileIO.CreateAndWrite(configPath, configYAML, "Configuration"); err != nil {
		return err
	}

	return nil
}

func (g *InstallConfig) WriteVault(vaultPath string, withComments bool) error {
	if g.Config == nil {
		return fmt.Errorf("no configuration provided - config is nil")
	}

	vault := g.Config.ExtractVault()
	vaultYAML, err := vault.Marshal()
	if err != nil {
		return fmt.Errorf("failed to marshal vault.yaml: %w", err)
	}

	if withComments {
		vaultYAML = AddVaultComments(vaultYAML)
	}

	if err := g.fileIO.CreateAndWrite(vaultPath, vaultYAML, "Secrets"); err != nil {
		return err
	}

	return nil
}

func AddConfigComments(yamlData []byte) []byte {
	header := `# Codesphere Installer Configuration
# Generated by OMS CLI
#
# This file contains the main configuration for installing Codesphere Private Cloud.
# Review and modify as needed before running the installer.
#
# For more information, see the installation documentation.

`
	return append([]byte(header), yamlData...)
}

func AddVaultComments(yamlData []byte) []byte {
	header := `# Codesphere Installer Secrets
# Generated by OMS CLI
#
# IMPORTANT: This file contains sensitive information!
#
# Before storing or transmitting this file:
# 1. Install SOPS and Age: brew install sops age
# 2. Generate an Age keypair: age-keygen -o age_key.txt
# 3. Encrypt this file:
#    age-keygen -y age_key.txt  # Get public key
#    sops --encrypt --age <PUBLIC_KEY> --in-place prod.vault.yaml
#
# Keep the Age private key (age_key.txt) extremely secure!
#
# To edit the encrypted file later:
#    export SOPS_AGE_KEY_FILE=/path/to/age_key.txt
#    sops prod.vault.yaml

`
	return append([]byte(header), yamlData...)
}

func (g *InstallConfig) ValidateConfig() []string {
	errors := []string{}

	if g.Config.Datacenter.ID == 0 {
		errors = append(errors, "datacenter ID is required")
	}
	if g.Config.Datacenter.Name == "" {
		errors = append(errors, "datacenter name is required")
	}

	if g.Config.Postgres.Mode == "" {
		errors = append(errors, "postgres mode is required (install or external)")
	} else if g.Config.Postgres.Mode != "install" && g.Config.Postgres.Mode != "external" {
		errors = append(errors, fmt.Sprintf("invalid postgres mode: %s (must be 'install' or 'external')", g.Config.Postgres.Mode))
	}

	switch g.Config.Postgres.Mode {
	case "install":
		if g.Config.Postgres.Primary == nil {
			errors = append(errors, "postgres primary configuration is required when mode is 'install'")
		} else {
			if g.Config.Postgres.Primary.IP == "" {
				errors = append(errors, "postgres primary IP is required")
			}
			if g.Config.Postgres.Primary.Hostname == "" {
				errors = append(errors, "postgres primary hostname is required")
			}
		}
	case "external":
		if g.Config.Postgres.ServerAddress == "" {
			errors = append(errors, "postgres server address is required when mode is 'external'")
		}
	}

	if len(g.Config.Ceph.Hosts) == 0 {
		errors = append(errors, "at least one Ceph host is required")
	}
	for _, host := range g.Config.Ceph.Hosts {
		if !IsValidIP(host.IPAddress) {
			errors = append(errors, fmt.Sprintf("invalid Ceph host IP: %s", host.IPAddress))
		}
	}

	if g.Config.Kubernetes.ManagedByCodesphere {
		if len(g.Config.Kubernetes.ControlPlanes) == 0 {
			errors = append(errors, "at least one K8s control plane node is required")
		}
	} else {
		if g.Config.Kubernetes.PodCIDR == "" {
			errors = append(errors, "pod CIDR is required for external Kubernetes")
		}
		if g.Config.Kubernetes.ServiceCIDR == "" {
			errors = append(errors, "service CIDR is required for external Kubernetes")
		}
	}

	if g.Config.Codesphere.Domain == "" {
		errors = append(errors, "Codesphere domain is required")
	}

	return errors
}

func ValidateVault(vault *files.InstallVault) []string {
	errors := []string{}
	requiredSecrets := []string{"cephSshPrivateKey", "selfSignedCaKeyPem", "domainAuthPrivateKey", "domainAuthPublicKey"}
	foundSecrets := make(map[string]bool)

	for _, secret := range vault.Secrets {
		foundSecrets[secret.Name] = true
	}

	for _, required := range requiredSecrets {
		if !foundSecrets[required] {
			errors = append(errors, fmt.Sprintf("required secret missing: %s", required))
		}
	}

	return errors
}

func IsValidIP(ip string) bool {
	return net.ParseIP(ip) != nil
}
